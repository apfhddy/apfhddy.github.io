오늘 부터 백준 알고리즘 푼것도 한번 올려 볼려 한다.

오늘 풀어볼 문제는 6단계 분수찾기이다.

## 문제
무한히 큰 배열에 다음과 같이 분수들이 적혀있다.  
<table border="1">
    <tbody>
        <tr>
            <td>1/1</td>
            <td>1/2</td>
            <td>1/3</td>
            <td>1/4</td>
            <td>1/5</td>
            <td>...</td>
        </tr>
        <tr>
            <td>2/1</td>
            <td>2/2</td>
            <td>2/3</td>
            <td>2/4</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <td>3/1</td>
            <td>3/2</td>
            <td>3/3</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <td>4/1</td>
            <td>4/2</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr>
            <td>5/1</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
         <tr>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
    </tbody>
</table>  
이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.

## 분석
1 == 1/1
2 == 1/2

나는 저게 결국 y/x값이 라고 생각했다.  
1 == (y == 1 / x == 1)  
2 == (y == 1 / x == 2)  
이걸 기준으로 코드를 짜보겠다. 이거 아니면 배열인데 배열은 공간복잡도상 x,y가 괜찮을 듯 십다.
  
생각해볼 것이 반복문으로 일일이 이동시키면서 해야하나? 이다.  
그러면 입력이 X(1 ≤ X ≤ 10,000,000) 즉 최대값이 나오게 되면 그걸 다해야 멈춘다. = 손해다. 근데 이거 밖에 생각이 안난다. 
아니면 행을 탐색하는 것은 어떨까? 몇번째 행인지 찾아낸후 결과를 도출하는것. 1/1 이후엔 1/2 , 2/1 이렇게 2개가 나온다.  
총 3개 가 되는 것이다. 다음은 총 6(max)개 이걸 탐욕알고리즘을 통해서 몇 번째 행인지 알 수 있을 것이다.  
```java
int n = X; //실행 횟수
		
int max = 0;//총 개수 
int i = 0;// 행
while(n > max) {
    max += ++i;
}
int index = n - max; // 실행횟수 빼기 총 횟수 

System.out.println(index +" "+max+" "+i);
		
// n = 4 일 경우 index( -2 ) max(  6 ) i( 3 )
// n = 5 일 경우 index( -1 ) max(  6 ) i( 3 ) 
// n = 6 일 경우 index(  0 ) max(  6 ) i( 3 )
// n = 7 일 경우 index( -3 ) max( 10 ) i( 4 )
// n = 8 일 경우 index( -2 ) max( 10 ) i( 4 )
```
위에 표를 보면 4, 5, 6은 모두 같은 행이다.  
max도 맞다.  
index를 조금 손 봐야 할것이 위에서 내려오는 경우 아내서 올라오는 경우가 있다. 이경우는 몇번째 행이냐에 따라 알 수 있다. 
1행 모름  
2행 위 -> 아래  
3행 아래 -> 위  
4행 위 -> 아래  

이로 알 수 있는 것은 행이 ( 짝수 = 위 -> 아래 / 홀수 아래 -> 위 )
이것으로 값을 처리하면 될듯 하다



